---
title: Chapter.14 - 가상 메모리
date: 2023-09-01 21:30:00 +0900
categories: [Computer Science]
tags: [cs, 혼공]
img_path: /assets/img/posts/cs/
---

> 모든 이미지의 저작권은 **[혼자 공부하는 컴퓨터 구조 + 운영체제]** 도서의 저자 **강민철**님에게 있습니다.
{: .prompt-warning }

## **<u>연속 메모리 할당</u>**

메모리 내에 연속적으로 프로세스를 배치하는 방식

## **<u>스와핑</u>**

대기 상태가 됐거나 오랫동안 사용되지 않은 프로세스들을 임시로 `보조기억장치 일부 영역`{: .custom-highlight }으로 쫓아내고 그렇게 해서 생긴 메모리의 빈 공간에 또 다른 프로세스를 배치하여 실행하는 방식

- 쫓겨난 프로세스들이 위치한 보조기억장치의 영역 : `스왑 영역`{: .custom-highlight }

- 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것 : `스왑 아웃`{: .custom-highlight }

- 스왑 영역에 있는 프로세스가 메모리로 옮겨지는 것 : `스왑 인`{: .custom-highlight }

스왑 아웃되기 전의 주소와 스왑 인 된 후 주소는 다를 수 있다.

![14-1.png](14-1.png)

## **<u>메모리 할당</u>**

비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 대표적인 방식 3가지

#### **\* 최초 적합**

운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식

검색을 최소화할 수 있어서 빠른 할당이 가능

#### **\* 최적 적합**

운영체제가 메모리 내의 빈 공간을 모두 검색한 후 프로세스가 적재될 수 있는 가장 작은 공간에 프로세스를 배치하는 방식

#### **\* 최악 적합**

운영체제가 메모리 내의 빈 공간을 모두 검색한 후 프로세스가 적재될 수 있는 가장 큰 공간에 프로세스를 배치하는 방식

## **<u>연속 메모리 할당의 문제 - 외부 단편화</u>**

메모리 공간은 많지만 프로세스를 배치하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상

예를 들어, 메모리에 20mb , 30mb , 40mb 크기의 빈 공간이 있지만 50mb 크기의 프로세스를 적재하지 못하는 것

#### **\* 해결 방안**

메모리 압축 : 흩어져 있는 메모리의 빈 공간들을 하나로 모으는 방법

#### **\* 단점**

- 압축하는 동안 시스템이 하던 일은 중지된다.
- 메모리에 있는 내용을 옮기는 작업이 많은 오버헤드를 야기한다.
- 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정짓기 어렵다.

![14-2.png](14-2.png)

## **<u>가상 메모리</u>**

실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술

## **<u>페이징</u>**

메모리의 물리 주소 공간을 `프레임 단위`{: .custom-highlight }로 자르고 프로세스의 논리 주소 공간을 `페이지 단위`{: .custom-highlight }로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법

프로세스를 작은 단위 + 불연속적으로 메모리에 배치하기 때문에 외부 단편화 문제를 해결할 수 있다.

![14-3.png](14-3.png)

페이지도 스왑 아웃/스왑 인 될 수 있으며 페이징 시스템에서는 이를 `페이지 아웃/페이지 인`{: .custom-highlight }이라고 부르기도 한다.

또한, 실행에 필요한 페이지만 메모리에 배치하고 나머지는 보조기억장치의 스왑 영역에 배치함으로써 메모리 크기보다 큰 프로세스를 실행할 수 있다.

![14-4.png](14-4.png)

## **<u>페이지 테이블</u>**

프로세스가 작은 단위로 나뉘어져 불연속적으로 메모리에 배치되어 있어 CPU가 프로세스를 실행하기가 어렵다.

이를 해결하기 위해 페이지 번호와 프레임 번호가 적힌 `페이지 테이블`{: .custom-highlight }을 이용한다.

![14-5.png](14-5.png)

> 내부 단편화
> : 모든 프로세스가 페이지 크기로 딱 맞게 나눠지지 않기 떄문에 생기는 메모리 낭비
> ![14-6.png](14-6.png)
{: .prompt-info }

각 프로세스마다 페이지 테이블을 가지고 있고 페이지 테이블은 PCB에 기록되어 메모리에 적재되어 있다.

CPU는 현재 실행중인 프로세스의 페이지 테이블 주소를 `페이지 테이블 베이스 레지스터 (PTBR)`{: .custom-highlight }에 저장하고 있다.

![14-7.png](14-7.png)

## **<u>TLB (Translation Lookaside Buffer)</u>**

페이지 테이블이 메모리에 적재되어 있기 때문에 CPU가 메모리에 두 번 접근해야 하는 문제가 있다.

이를 해결하기 위해 페이지 테이블의 일부를 TLB 에 저장하며, 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장한다.

![14-8.png](14-8.png)

## **<u>페이징 시스템의 주소 구성</u>**

페이징 시스템에서는 모든 논리 주소가 `페이지 번호 + 변위`{: .custom-highlight }로 이루어져 있다.

논리 주소는 페이지 테이블을 거쳐 `프레임 번호 + 변위`{: .custom-highlight }형태의 물리 주소로 변환된다.

![14-9.png](14-9.png)

## **<u>페이지 테이블 자세히 보기</u>**

페이지 테이블의 각 행을 `페이지 테이블 엔트리`{: .custom-highlight }라고 하며 페이지 테이블 엔트리는 아래와 같이 구성되어 있다.

![14-10.png](14-10.png)

#### **\* 유효 비트**

현재 페이지가 `메모리에 적재되어 있는지 판별`{: .custom-highlight }하는 비트

0 = 페이지가 메모리에 적재되어 있지 않다.

1 = 페이지가 메모리에 적재되어 있다.

CPU가 유효 비트가 0인 페이지에 접근하면 페이지 폴트라는 예외가 발생한다.

예외가 발생하면 CPU는 기존의 작업 내역을 백업하고 페이지 폴트 처리 루틴을 실행해서 페이지를 메모리로 가져온 후 유효 비트를 1로 변경한다.

#### **\* 보호 비트**

보호 비트는 r (읽기) , w (쓰기) , x (실행) 세 개의 비트로 구성되어 있다.

각 비트의 값을 통해 `페이지의 권한`{: .custom-highlight }을 알 수 있다.

#### **\* 참조 비트**

`CPU가 이 페이지에 접근한 적이 있는지`{: .custom-highlight } 여부를 나타낸다.

#### **\* 수정 비트**

`페이지가 변경된 적이 있는지`{: .custom-highlight } 판별하는 비트

변경된 적이 있는 페이지라면 스왑 아웃될 때 변경된 값을 보조기억장치에 기록하는 작업이 추가로 필요하다.

> 페이징의 이점 - 쓰기 시 복사
> : 부모 프로세스와 동일한 자식 프로세스가 생성될 때 부모 프로세스의 프레임을 자식 프로세스와 공유하다가 자식 프로세스가 쓰기 작업을 할 때 자식 프로세스만의 고유한 페이지와 프레임이 생성되도록 하는 기법
{: .prompt-info }

## **<u>운영체제가 수많은 페이지를 관리하고 적절히 프레임을 할당하는 방법</u>**

`요구 페이징`{: .custom-highlight } : 실행에 요구되는 페이지만 메모리에 적재하는 기법

`순수 요구 페이징`{: .custom-highlight } : 페이지를 메모리에 적재하지 않은 채 프로세스의 첫 페이지를 실행하여 페이지 폴트를 일으키고 어느 정도 페이지가 적재된 이후부터 페이지 폴트 발생 빈도를 떨어뜨리는 기법

페이징 시스템이 안정적으로 작동하기 위해서는 `페이지 교체`{: .custom-highlight } , `프레임 할당`{: .custom-highlight } 이 중요하다.

## **<u>페이지 교체</u>**

페이지 교체 알고리즘 : 실행에 필요한 페이지를 메모리에 적재하기 위해 스왑 아웃 할 페이지를 결정하는 방법

좋은 페이지 교체 알고리즘은 페이지 폴트가 적게 일어나는 알고리즘

즉, 페이지 폴트 횟수를 알아야하고 이는 `페이지 참조열`{: .custom-highlight }을 통해 알 수 있다.

페이지 참조열은 CPU가 참조한 페이지를 나열하고 연속된 페이지 번호를 제거한 것

![14-11.png](14-11.png)
_참조한 페이지 나열_

![14-12.png](14-12.png)
_페이지 참조열_

## **<u>대표적인 페이지 교체 알고리즘</u>**

#### **\* FIFO 페이지 교체 알고리즘**

가장 먼저 메모리에 올라온 페이지부터 스왑 아웃 하는 알고리즘

![14-13.png](14-13.png)

> 2차 기회 페이지 교체 알고리즘
> : FIFO 페이지 교체 알고리즘과 같이 가장 먼저 메모리에 올라온 페이지부터 선별하지만 해당 페이지의 참조 비트가 1일 경우 당장 스왑 아웃 하지않고 참조 비트를 0으로 변경 후 적재 시간을 현재 시간으로 변경하는 알고리즘
> ![14-14.png](14-14.png)
{: .prompt-info }

#### **\* 최적 페이지 교체 알고리즘**

CPU에 의해 참조되는 횟수를 고려하여 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘

![14-15.png](14-15.png)

가장 낮은 페이지 폴트율을 보장하는 알고리즘이지만 실제 구현이 어렵기 때문에 주로 다른 페이지 교체 알고리즘의 성능을 평가하기 위한 목적으로 사용된다.

즉, 최적 페이지 교체 알고리즘에서 발생하는 페이지 폴트 횟수를 하한선으로 간주하고 이와 비교하여 다른 알고리즘의 페이지 폴트 횟수를 평가하기 위해 사용한다.

#### **\* LRU 페이지 교체 알고리즘**

가장 오랫동안 사용되지 않은 페이지를 교체하는 알고리즘

![14-16.png](14-16.png)

## **<u>프레임 할당</u>**

`스래싱`{: .custom-highlight } : 지나치게 빈번한 페이지 교체로 인해 CPU 이용률이 낮아지는 문제

![14-17.png](14-17.png)

적당한 수의 프로세스를 동시에 실행시키면 CPU 이용률이 높아지지만 너무 많으면 각 프로세스가 사용할 수 있는 프레임 수가 적어져 페이지 폴트가 자주 일어나 CPU 이용률이 낮아지고 성능이 나빠진다.

## **<u>프레임 할당 방식</u>**

#### **\* 균등 할당**

모든 프로세스에 동일한 프레임을 배분하는 방식

#### **\* 비례 할당**

프로세스 크기에 따라 프레임을 배분하는 방식

#### **\* 작업 집합 모델 기반 할당**

프로세스가 일정 기간 동안 참조한 페이지 집합을 `작업 집합`{: .custom-highlight }이라고 한다.

작업 집합 모델 기반 할당은 작업 집합의 크기만큼만 프레임을 할당하는 방식이다.

![14-18.png](14-18.png)

![14-19.png](14-19.png)

#### **\* 페이지 폴트 빈도 기반 할당**

할당된 프레임의 수와 페이지 폴트율을 비교하여 상한선과 하한선을 두고 그 범위 안에서만 프레임을 할당하는 방식

![14-20.png](14-20.png)